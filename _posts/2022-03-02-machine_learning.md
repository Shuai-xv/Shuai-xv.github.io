---
layout: post
title:  "机器学习"
author: shuai
categories: [ shuai, tutorial ]
image: assets/images/18.jpg
hidden: true
---

这是测试

> - 《[南瓜书](https://datawhalechina.github.io/pumpkin-book/#/)》的所有内容都是以西瓜书的内容为前置知识进行表述的，所以南瓜书的最佳使用方法是以西瓜书为主线，遇到自己推导不出来或者看不懂的公式时再来查阅南瓜书；
>
> - 对于初学机器学习的小白，西瓜书第1章和第2章的公式**强烈不建议深究**，简单过一下即可，等你学得有点飘的时候再回来啃都来得及；
>
---
>
> - 本书用 “模型” 泛指从数据中学得的结果. 有文献用 “模型” 指全局性结 果(例如一棵决策树), 而用 “模式” 指局部性结果(例如一条规则).

---

---

---

### Rosenblatt感知器

```flow
start=>start: start
id1=>operation: 输入x
id2=>operation: 估计输出y=wx
id3=>operation: 标准答案-y=误差
id4=>operation: 更新w：w=w+α*误差*x
	
start->id1->id2->id3->id4(right)->id1
```

---

==代价函数==（现代神经网络精髓之一，误差和预测函数中的参数又形成的函数关系），[方差、均方差、均方误差，均方根误差、平方误差]

> > $e=a w^{2}+b w+c$

正规方程：（数据一大就不好了）

![image-20220211144453836](机器学习.assets/image-20220211144453836.png)

梯度下降：（梯度是比斜率更广泛的概念，在更高维度比斜率合适）

![image-20220211150841866](机器学习.assets/image-20220211150841866.png)

+ 依次在单样本代价函数上面进行梯度下降，虽然会有震荡和波动，但最终会趋向最优点-->因为其收敛的过程是一个随即震荡的轨迹，叫<kbd>随机梯度下降</kbd>。==慢且不一定能达到最优点==

+ 直接用全部样本（合成总代价函数）进行梯度下降，那么下降过程明确且顺滑，这叫标准梯度下降（<kbd>批量梯度下降</kbd>）。==同样海量数据不行==

* 上面两种调和，每次取几百个数据

![image-20220211164819093](机器学习.assets/image-20220211164819093.png)

![image-20220211171617601](机器学习.assets/image-20220211171617601.png)

==注：下面框里面的db的求导应放在上面的框里面的w调整之前==

---

---

## 激活函数

![image-20220212161023033](机器学习.assets/image-20220212161023033.png)

![image-20220212161157222](机器学习.assets/image-20220212161157222.png)

==它比阶跃函数好,因为它处处可导,便于梯度下降.==

标准的logistic函数就是默认的sigmoid函数

和之前不同

$z=αx+b$  (毒性大小)

--> $a=sigmoid(z)$  (有毒概率)

==>$a=\operatorname{sigmoid}(w x+b)$

**z或许不应该理解为毒性大小,激活函数的自变量是应该正负都有的,==线性函数依然存在应该是为了将自变量(豆豆大小)转换到激活函数的定义域==**

方差代价函数变为:(a是预测结果,y是实际结果)
$$
\begin{aligned}
e &=(y-a)^{2} \\
&=(y-\operatorname{sigmoid}(w x+b))^{2}
\end{aligned}
$$
$$
\operatorname{sigmoid}(x)=\frac{1}{1+e^{-x}}
$$
复合求导把把反向传播和梯度下降这两个现代神经网络的基石优美的结合在一起

==多层感知器本制是一个嵌套的非常深的复合函数==.

==线性函数无论怎么叠加,最终仍然是线性的.而激活函数是非线性的,他让神经网络摆脱了线性的约束,具备了处理复杂问题的能力.==

![image-20220213135435707](机器学习.assets/image-20220213135435707.png)

模型的==泛化==能力是追求的核心

![image-20220213135728468](机器学习.assets/image-20220213135728468.png)

深度就是纵向隐藏层比较深,超过三层就可称为深度神经网络

---

![image-20220213201203359](机器学习.assets/image-20220213201203359.png)

![image-20220213201330524](机器学习.assets/image-20220213201330524.png)

![image-20220213202043171](机器学习.assets/image-20220213202043171.png)

![image-20220213202300660](机器学习.assets/image-20220213202300660.png)

训练好了之后使用`model.predict(X)`输出预测结果

`optimizer='sgd'`也可以用`optimizer=SGD(lr=0.05)`指定学习率

有多个层的时候多次用`model.add(...)`

![image-20220213203221954](机器学习.assets/image-20220213203221954.png)

---

![image-20220213203408891](机器学习.assets/image-20220213203408891.png)

以调节神经网络的大致行为.

![image-20220213204836455](机器学习.assets/image-20220213204836455.png)

最流行的激活函数是==relu激活函数==,导数为0时,神经元死亡

没有特殊要求时relu应作为第一选择,在输出层中,sigmoid的上下限正好在0~1,适合做分类.

==用线性函数组合,用激活函数输出,用代价函数评估,用梯度下降优化==

==sigmoid激活函数只适合二分类,所以输出层用一个神经元就够了,当输出有多种情况时,输出层就要多个神经元.==

这是一个识别0-9的数字的模型,10输出模型,输出层就是个神经元

![这是一个识别0-9的数字的模型](机器学习.assets/image-20220213221227932.png)

---

---

![image-20220213214747933](机器学习.assets/image-20220213214747933.png)

![image-20220213214832359](机器学习.assets/image-20220213214832359.png)

![image-20220213215207534](机器学习.assets/image-20220213215207534.png)

![image-20220213221014029](机器学习.assets/image-20220213221014029.png)

==可以通过一定手段把输入的范围调小点,效果更好==

![image-20220213223939786](机器学习.assets/image-20220213223939786.png)

卷积核的参数思想普通神经元的的权重一样训练出来的



![image-20220213225836319](机器学习.assets/image-20220213225836319.png)

上面卷积后展开数据就少多了

==**什么是卷积层?什么是全连接层?**==应该就是卷积后展开和直接展开吧...

池化层...就是对卷积后的层操作,每次在一个m*m的区域内取max,min,average...等值,池化后又变细了.(不难发现此话不需要参数)

对图片直接展开,就忽略了图片空间的依赖性,卷积后展开就保存了空间的依赖性？？？是这样理解的吗

### 自然语言处理

**RNN循环神经网络**

![image-20220214093616922](机器学习.assets/image-20220214093616922.png)

![image-20220214093646189](机器学习.assets/image-20220214093646189.png)

循环神经网络不会太深，一般2-3层

![image-20220214094330965](机器学习.assets/image-20220214094330965.png)

故引入LSTM（long short-term memory)**长短时神经网络**

![image-20220214094953314](机器学习.assets/image-20220214094953314.png)

![image-20220214095210283](机器学习.assets/image-20220214095210283.png)

GRU结构更简单，效果和LSTM接近

博客[理解LSTM网络](https://colah.github.io/posts/2015-08-Understanding-LSTMs/)

![image-20220214095632602](机器学习.assets/image-20220214095632602.png)

---

生成式任务相比普通的分类、tagging等NLP任务会复杂不少。在生成的时候，模型的输出是一个时间步一个时间步依次获得的，而且前面时间步的结果还会影响后面时间步的结果。也就是说，每一个时间步，模型给出的都是基于历史生成结果的条件概率。为了生成完整的句子，需要一个称为解码的额外动作来融合模型多个时间步的输出，而且使得最终得到的序列的每一步条件概率连乘起来最大。

**这就是seq2seq中的beam search算法过程，但是可能有些同学有一个疑问，就是但i-1时刻选择的单词不同的时候，下一时刻的输出概率分布为什么会改变？**

这是由于解码的过程中，第i时刻的模型的输入，包括了第i-1时刻模型的输出，那么很自然在第i-1时刻模型的输出不同的时候，就会导致下一时刻模型的输出概率分布会不同，因为第i-1时刻的输出作为参数影响了后一时刻模型的学习



---

CTC有一重要特点便是它在计算时默认每一个时间步预测出字符为条件独立事件，这一特点的优势在于不受训练集隐含的语言环境所限制，但如果需要语言模型来辅助预测，也可以在解码时也可以将语言模型与前缀束搜索相结合。

![image-20220218093822789](机器学习.assets/image-20220218093822789.png)

![image-20220218094023045](机器学习.assets/image-20220218094023045.png)

![image-20220218095451954](机器学习.assets/image-20220218095451954.png)

![image-20220218100334999](机器学习.assets/image-20220218100334999.png)

[这是一个seq2seq模型的beam search的搜索过程链接](https://zhuanlan.zhihu.com/p/28048246)

![image-20220220162742814](机器学习.assets/image-20220220162742814.png)

gradient descent有local minima的问题

==$w^{*}, b^{*}=\arg \min _{w, b} L$表示使目标$L$最小时候的$w,b$的取值==

---

![image-20220220181825691](机器学习.assets/image-20220220181825691.png)

**机器学习的框架有三步:**

![image-20220220182125189](机器学习.assets/image-20220220182125189.png)

![image-20220220203252964](机器学习.assets/image-20220220203252964.png)

![image-20220220203328898](机器学习.assets/image-20220220203328898.png)

![image-20220220203619102](机器学习.assets/image-20220220203619102-16453605803611.png)

epach和update区分,batch

![image-20220221224508310](机器学习.assets/image-20220221224508310.png)

为什么神经网络要做的很深,而不是横向扩展。

![image-20220223150314933](机器学习.assets/image-20220223150314933.png)

**关于怎么处理过拟合：用更多测试数据，方法由上面两种，还可以减小模型的灵活性**